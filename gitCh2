### . GIT의 기초

- 2-1 Git 저장소 만들기
    
    배울것들 : Git 저장소를 만들고 설정하는 방법, 파일을 추적하거나 추적을 중지하는 방법, 변경 내용을 준비하고 커밋하는 방법, 그리고 리모트 저장소와 소통하는 방법.
    
    Git 저장소를 사용하는 데는 크게 두 가지 방법이 있다
    
    - **아직 버전관리를 하지 않는 로컬 디렉토리 하나를 선택해서 Git 저장소를 적용하는 방법**
        
        **기존 디렉토리를 Git 저장소로 만들기**
        
        이미 작업하고 있는 프로젝트 디렉토리에 Git 저장소를 생성할 수 있다. 프로젝트 디렉토리로 이동한 후, **`git init`** 명령어를 사용하면 해당 디렉토리에 **`.git`**이라는 하위 디렉토리가 생성된다. 이 디렉토리는 Git 저장소의 뼈대 파일들을 포함하고 있다. 그 후 **`git add`** 명령어로 원하는 파일을 추가하고 **`git commit`** 명령어를 사용하여 변경 사항을 커밋할 수 있다.
        
        ```bash
        $ cd /path/to/my/project
        $ git init
        $ git add <files_to_add>
        $ git commit -m 'My commit message'
        ```
        
    - **다른곳에서 Git 저장소를 Clone 하는 방법**
        
        **Git 저장소를 Clone 하기**
        
        다른 사람의 Git 저장소를 복제하여 자신의 로컬에 저장소를 만들 수 있다. 이 때 **`git clone`** 명령어를 사용한다. 이 명령은 원격 저장소의 모든 데이터와 히스토리를 복제한다. 
        
        예시:
        
        ```bash
        $ git clone https://github.com/example/repo.git
        ```
        
        저장소를 특정 디렉토리 이름으로 클론하려면 다음과 같이 실행할 수 있다.
        
        ```bash
        $ git clone https://github.com/example/repo.git custom_directory_name
        ```
        
- 2-2 수정하고 저장소에 저장하기
    
    Git은 파일을 관리하는데, 그 파일들은 특정 상태에 있을 수 있다. 이는 Git이 프로젝트의 변경사항을 추적하는 방식과 관련이 있다. 
    
    - 워킹 디렉토리(작업 디렉토리)에 있는 파일들의 주요상태와 이들 간의 전환에 대해 요약
        - **Untracked (관리대상이 아님)**
            
            이 상태의 파일들은 Git에 의해 관리되고 있지 않음.
            즉, 이전에는 존재하지 않던 새로운 파일이거나, Git이 그 존재를 모르는 파일이다.
            
        - **Tracked (관리대상임)**
            
            Git이 변경 사항을 추적하는 파일.
            
            Tracked 파일은 다시 세 가지 하위 상태로 나눌 수 있다
            
            - **Unmodified (수정하지 않음)**
                
                최근 커밋 이후에 변경되지 않은 파일임
                즉, 파일의 내용이 이전 커밋과 동일하다.
                
            - **Modified (수정함)**
                
                최근 커밋 이후에 변경된 파일임
                변경사항은 아직 Staging Area에 추가되지 않았으며, 커밋되지도 않았음
                
            - **Staged (커밋할 준비가 됨)**
                
                수정된 파일 중에서 곧 커밋할 변경사항을 담고 있는 파일임
                이 상태는 커밋하기 직전의 상태로, Staging Area에 추가된 파일들이다.
                
    - Git의 기본적인 작업 흐름
        - **파일 수정**
            
            워킹 디렉토리에서 파일을 변경한다. 변경된 파일은 Modified 상태가 된다.
            
        - **Staging에 추가**
            
            변경된 파일들 중에서 커밋할 파일들을 선택하여 Staging Area에 추가한다. 이 때, **`git add <파일명>`** 명령을 사용한다. 해당 파일들은 Staged 상태가 된다.
            
        - **커밋**
            
            Staging Area에 있는 파일들의 스냅샷을 저장소에 저장한다. 이 때, **`git commit`** 명령을 사용한다. 커밋된 파일들은 다시 Unmodified 상태가 된다.
            
        - **반복**
            
            프로젝트에서 계속 작업하며, 이러한 단계들을 반복한다.
            
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fc034981-30cc-4f06-9a94-10160b58c146/Untitled.png)
    
    - **파일 상태 확인하기**
        
        **`git status`** 명령을 사용하여 워킹 디렉토리 내 파일들의 상태를 확인할 수 있다.
        
        ```bash
        $ git status
        #처음 저장소를 복제한 후에는, 파일들이 수정되지 않았으므로,
        'nothing to commit, working directory clean'
        #이라는 메시지가 표시된다.
        ```
        
    - ****파일을 새로 추적하기****
        
        새 파일(예: README)을 생성한 후, **`git add`** 명령을 사용하여 해당 파일을 Git에 추적하도록 설정한다
        
        ```bash
        $ echo 'My Project' > README
        $ git add README
        ```
        
        **`git status`**를 다시 실행하면, README 파일이 Staged 상태에 있음을 확인할 수 있다. 
        이는 커밋될 준비가 된 상태이다.
        
    - ****Modified 상태의 파일을 Stage 하기****
        
        이미 Tracked 상태인 파일을 수정하는 법
        
        - **파일 수정**
            
            Tracked 상태인 **`CONTRIBUTING.md`** 파일을 수정한다. 이 파일은 Git에 의해 이미 추적되고 있는 상태이다.
            
        - **상태 확인**
            
            수정한 후 **`git status`** 명령을 사용하여 Git의 상태를 확인한다. 여기서 Git은 **`CONTRIBUTING.md`** 파일이 수정되었으나 아직 Staged 상태가 아니라고 알려준다.
            
            ```bash
            $ git status
            ```
            
        - **Staging Area에 추가**
            
            **`git add`** 명령을 사용하여 수정한 파일을 Staging Area에 추가한다. 이는 다음 커밋에 파일 변경 사항이 포함되도록 준비하는 단계이다.
            
            ```bash
            $ git add CONTRIBUTING.md
            ```
            
        - **상태 재확인**
            
            **`git status`** 명령으로 다시 상태를 확인하면, **`CONTRIBUTING.md`** 파일이 Staged 상태로 변경된 것을 확인할 수 있다.
            
        - **추가적인 수정**
            
            만약 **`CONTRIBUTING.md`** 파일을 다시 수정한다면, 이 파일은 Staged 상태이면서 동시에 Unstaged 상태가 된다. 이는 **`git add`** 명령을 사용하여 파일을 Staging Area에 추가한 시점의 내용만 Staged 상태로 남아있고, 이후 수정한 내용은 아직 Staged 상태가 아니기 때문이다.
            
        - **최신 내용 Staging Area에 추가**
            
            추가적으로 수정한 내용을 Staging Area에 반영하려면, 다시 **`git add`** 명령을 실행해야 한다.
            
            ```bash
            $ git add CONTRIBUTING.md
            ```
            
        - **최종 상태 확인**
            
            **`git status`**를 사용하여 최종 상태를 확인하면, **`CONTRIBUTING.md`** 파일이 Staged 상태로 표시된다. 이제 커밋 명령을 실행하여 변경 사항을 저장소에 반영할 수 있다.
            
        - **요약**
            
            이 과정을 요약하면, 파일을 수정한 후에는 **`git add`** 명령을 사용하여 변경 사항을 Staging Area에 추가해야 하며, 추가적으로 수정하는 경우엔 **`git add`**를 다시 실행하여 최신 내용을 Staging Area에 반영해야 한다. 이후 **`git commit`** 명령을 사용하여 변경 사항을 커밋한다.
            
    - **파일 상태를 짤막하게 확인하기**
        
        이 부분은 **`git status`**의 짧은 형식을 이용하여 파일 상태를 간결하게 확인하는 방법과, 특정 파일들을 Git의 추적에서 제외하는 **`.gitignore`** 파일에 대해 설명하고 있습니다.
        
        1. **짧은 상태 확인**
            
            **`git status -s`** 또는 **`git status --short`** 명령을 사용하면 상태를 더 간결하게 확인할 수 있습니다.
            
            ```
            shCopy code
            $ git status -s
            
            ```
            
            출력 예시:
            
            ```
            bashCopy code
            M README           # 수정된 파일 (Modified)
            MM Rakefile        # Staged 후 수정된 파일 (Modified after being staged)
            A  lib/git.rb      # 새로운 파일 (Added to the staging area)
            ?? LICENSE.txt     # 추적되지 않는 파일 (Untracked file)
            
            ```
            
            **`M`**은 수정된 파일, **`A`**는 새로 추가된 파일을 나타냅니다. 왼쪽 상태는 Staging Area에서의 상태, 오른쪽 상태는 Working Directory에서의 상태를 나타냅니다.
            
    - ****파일 무시하기****
        
        **`.gitignore`** 파일은 Git이 무시해야 하는 파일(보통 로그 파일이나 빌드 시스템이 자동으로 생성한 파일) 패턴을 지정하는데 사용다. 
        이 파일은 프로젝트의 루트 디렉토리에 생성해야하며, 각 라인에 무시할 파일 또는 디렉토리 패턴을 추가할 수 있다.
        
        `**.gitignore**` 파일은 보통 처음에 만들어 두는 것이 편리하다.
        
        `.**gitignore`** 파일에 입력하는 패턴은 아래 규칙을 따른다.
        
        - 아무것도 없는 라인이나, `**#`** 로 시작하는 라인은 무시한다.
        - 표준 Glob 패턴을 사용한다. 이는 프로젝트 전체에 적용된다.
        - 슬래시(`**/**`)로 시작하면 하위 디렉토리에 적용되지(Recursivity) 않는다.
        - 디렉토리는 슬래시(`**/**`)를 끝에 사용하는 것으로 표현한다.
        - 느낌표(`**!**`)로 시작하는 패턴의 파일은 무시하지 않는다.
        
        .gitignore 파일을 생성하고 적절한 규칙을 추가한 후, 이 파일을 Git에 추가하고 커밋해야 합니다.
        
        ```bash
        $ git add .gitignore
        $ git commit -m "Add .gitignore file"
        ```
        
        **`.gitignore`** 파일 예시:
        
        ```bash
        *.log             # .log 확장자를 가진 모든 파일 무시
        tmp/              # tmp 디렉토리와 그 내부의 모든 파일과 디렉토리 무시
        !example.log      # .gitignore에 의해 무시되지만 example.log는 예외로 무시하지 않음
        ```
        
        이렇게 하면 **`.gitignore`** 파일이 프로젝트에 적용되고 Git은 지정된 패턴에 맞는 파일들을 무시하게 된다.
        
    - ****Staged와 Unstaged 상태의 변경 내용을 보기****
        
        단순히 파일이 변경됐다는 사실이 아니라 어떤 내용이 변경됐는지 살펴보려면 `**git status`** 명령이 아니라 `**git** **diff`** 명령을 사용해야 한다.
        
        - **git status**
            
            현재 Git 리포지토리의 상태를 확인한다. 변경된 파일들 중 Staged 상태인 것과 Unstaged 상태인 것을 구별하여 보여준다.
            
            ```bash
            $ git status
            ```
            
        - **git diff**
            
            Unstaged 상태의 변경 사항을 확인한다. 즉, 작업 디렉토리(Working Directory)와 Staging Area 사이의 차이를 보여준다. 어떤 라인이 추가되었는지, 삭제되었는지를 확인할 수 있다.
            
            ```bash
            $ git diff
            ```
            
        - **git diff --staged (--cached)**
            
            Staged 상태의 변경 사항을 확인한다. Staging Area와 마지막 커밋 사이의 차이를 보여준다. (**`-cached`** 옵션을 사용하여 동일한 결과를 얻을 수 있다.)
            
            ```bash
            $ git diff --staged
            ```
            
            ```bash
            $ git diff --cached
            ```
            
        - **외부 도구로 비교하기**
            
            **`git difftool`** 명령을 사용하여 외부 도구로 변경 사항을 비교할 수 있다. 이를 통해 Diff 도구를 사용하여 더 세밀한 비교를 할 수 있다.
            
            ```
            $ git difftool
            ```
            
        
        요약하면, **`git status`**를 사용하여 변경된 파일들을 확인하고, **`git diff`**를 사용하여 변경 내용을 세부적으로 살펴볼 수 있다. **`git add`**를 통해 변경 사항을 Staging Area에 추가한 뒤, **`git diff --staged`**로 Staged 상태의 변경 사항을 확인할 수 있다. 추가적으로 **`git difftool`**을 사용하여 외부 도구로 변경 사항을 비교할 수도 있다.
        
    - ****변경사항 커밋하기****
        - **Staging Area 확인**
            
            커밋하기 전에 **`git status`** 명령어를 사용하여 변경 사항이 Staging Area에 올바르게 추가되었는지 확인한다.
            
            ```bash
            $ git status
            ```
            
        - **커밋하기**
            
            **`git commit`** 명령어를 사용하여 Staging Area의 내용을 커밋한다. 이 명령은 설정된 텍스트 에디터를 열어 커밋 메시지를 입력하도록 한다.
            
            ```bash
            $ git commit
            ```
            
            커밋 메시지는 **`#`**으로 시작하는 줄을 제외하고 저장된다.
            메시지를 저장하고 에디터를 닫으면 커밋이 완료된다.
            
            에디터는 Git 설정 또는 환경 변수에 따라 결정된다. 에디터를 변경하려면 **`git config --global core.editor`** 명령어를 사용할 수 있다.
            
        - **인라인 커밋 메시지**
            
            **`m`** 옵션을 사용하여 명령 줄에서 직접 커밋 메시지를 지정할 수 있다. 이렇게 하면 별도의 텍스트 에디터가 열리지 않는다.
            
            ```bash
            $ git commit -m "Your commit message here"
            ```
            
        - **커밋 정보 확인**
            
            커밋이 완료되면 `**commit**` 명령은 몇 가지 정보를 출력하는데. 이 정보에는 브랜치 이름, 커밋의 해시, 변경된 파일 수, 추가된 라인 수 등이 포함된다.
            
        - **커밋하는 것은 스냅샷을 저장하는 것**
            
            Git은 커밋 시점의 프로젝트 상태에 대한 스냅샷을 저장한다. Staging Area에 추가된 변경 사항만이 커밋에 포함됩니다. 이를 통해 나중에 다른 커밋과 비교하거나 특정 커밋 상태로 되돌아갈 수 있다.
            
        
        위의 단계를 통해 소스 코드의 변경 사항을 안전하게 저장하고 이력을 관리할 수 있다.
        
    - ****Staging Area 생략하기****
        
        Staging Area는 커밋할 파일을 정리한다는 점에서 매우 유용하지만 복잡하기만 하고 필요하지 않은 때도 있다. 
        Staging Area를 생략하는 방법은 일부 변경 사항을 빠르게 커밋하는데 유용하다.
        
        - **상태 확인**
            
            변경 사항이 있는지 확인하기 위해 **`git status`** 명령어를 사용한다. 이 명령어는 Staging Area에 추가되지 않은 변경된 파일들을 보여준다.
            
            ```bash
            $ git status
            ```
            
        - **Staging Area 생략하고 커밋하기**
            
            **`git commit`** 명령에 **`a`** 옵션을 추가하여 Staging Area 단계를 생략하고 추적 중인 모든 파일의 변경 사항을 바로 커밋할 수 있다. 커밋 메시지는 **`m`** 옵션을 사용하여 지정한다
            
            ```bash
            $ git commit -a -m "My commit message here"
            ```
            
            이 명령은 추적 중인 모든 파일을 자동으로 Staging Area에 추가하고 커밋한다.
            이렇게 하면 **`git add`** 명령을 별도로 실행할 필요가 없다.
            
        - **주의 사항**
            
            **`a`** 옵션은 편리하지만 신중하게 사용해야 한다. 이 옵션을 사용하면 모든 변경 사항이 커밋에 포함되므로, 원치 않는 변경 사항이 커밋될 수 있다.
            
        - **요약**
            
            요약하면, **`-a`** 옵션을 사용하여 **`git commit`** 명령을 실행하면 추적 중인 파일의 변경 사항을 자동으로 Staging Area에 추가하고 커밋한다. 이 방법은 빠르게 작업하고 싶을 때 유용하지만, 변경 사항을 신중하게 검토하지 않으면 원치 않는 변경 사항이 포함될 수 있으므로 주의가 필요하다.
            
    - ****파일 삭제하기****
        
        Git에서 파일을 제거하려면 **`git rm`** 명령으로 Tracked 상태의 파일을 삭제한 후에(정확하게는 Staging Area에서 삭제하는 것) 커밋해야 한다. 이 명령은 워킹 디렉토리에 있는 파일도 삭제하기 때문에 실제로 파일도 지워진다.
        
        **—단계**
        
        - **파일 삭제**
            
            먼저, 워킹 디렉토리에서 파일을 삭제한다. 이 때, **`rm`** 명령을 사용할 수 있다.
            
            ```bash
            $ rm PROJECTS.md
            ```
            
        - **상태 확인**
            
            **`git status`**를 사용하여 Git이 변경 사항을 감지했는지 확인한다. 이 명령어로 Git은 파일이 삭제되었으나 아직 Staging Area에 반영되지 않았음을 알려준다.
            
            ```bash
            $ git status
            ```
            
        - **Git으로 파일 삭제**
            
            **`git rm`** 명령어를 사용하여 Git에서 파일을 삭제하고 Staging Area에 반영한다. 이 명령은 워킹 디렉토리에서 파일을 삭제하는 것과 함께 Git에게도 이 파일을 추적하지 않도록 알린다.
            
            ```bash
            $ git rm PROJECTS.md
            ```
            
        - **변경 사항 커밋**
            
            마지막으로, 변경 사항을 커밋하여 저장소에 반영한다.
            
            ```bash
            $ git commit -m "Removed PROJECTS.md"
            ```
            
        - **추가 옵션**
            - **강제 삭제**
                
                이미 수정한 파일을 강제로 삭제하려면, **`f`** 옵션을 사용한다.
                
                ```bash
                $ git rm -f FILENAME
                ```
                
            - **Staging Area에서만 삭제**
                
                파일을 워킹 디렉토리에 그대로 두고 Git의 추적에서만 제거하려면, 다시 말해서 하드디스크에 있는 파일은 그대로 두고 Git만 추적하지 않게 하려면 **`-cached`** 옵션을 사용한다. 
                
                ```bash
                $ git rm --cached FILENAME
                ```
                
            - **패턴으로 삭제**
                
                특정 패턴에 일치하는 여러 파일을 한 번에 삭제할 수 있다. 예를 들어, 모든 **`.log`** 파일을 삭제하려면 다음과 같이 할 수 있다.
                
                ```bash
                $ git rm log/*.log
                ```
                
        
        결론적으로, Git에서 파일을 삭제할 때는 먼저 파일을 워킹 디렉토리에서 삭제한 후 **`git rm`** 명령어를 사용하여 Git에서 추적하지 않도록 설정하고, 마지막으로 변경 사항을 커밋한다. 이렇게 하면 파일은 Git 저장소에서 삭제되고 추적되지 않게 된다.
        
    - ****파일 이름 변경하기****
        
        Git은 다른 VCS 시스템과는 달리 파일 이름의 변경이나 파일의 이동을 명시적으로 관리하지 않는다. 다시 말해서 파일 이름이 변경됐다는 별도의 정보를 저장하지 않는다. Git은 똑똑해서 굳이 파일 이름이 변경되었다는 것을 추적하지 않아도 아는 방법이 있다.
        
        이렇게 말하고 Git에 `mv` 명령이 있는 게 좀 이상하겠지만, 아래와 같이 파일 이름을 변경할 수 있다.
        
        - **파일 이름 변경**
            
            **`git mv`** 명령어를 사용하여 파일의 이름을 변경한다. 이 명령은 기본적으로 파일을 이동하는 것과 이름을 변경하는 것 모두를 수행할 수 있다.
            
            ```bash
            $ git mv old_filename new_filename
            ```
            
            예를 들어, README.md 파일의 이름을 README로 변경하려면 다음과 같이 할 수 있다.
            
            ```bash
            $ git mv README.md README
            ```
            
        - **상태 확인**
            
            **`git status`** 명령을 사용하여 변경 사항이 Staging Area에 추가되었는지 확인할 수 있다. Git은 파일이 이름이 변경되었다는 것을 알아서 인식한다.
            
            ```bash
            $ git status
            ```
            
        - **변경 사항 커밋**
            
            변경 사항을 저장소에 반영하기 위해 커밋한다.
            
            ```bash
            $ git commit -m "Renamed README.md to README"
            ```
            
        
        위에서 언급한 **`git mv`** 명령어는 사실 세 개의 명령어의 단축이다. 즉, 파일을 이동(**`mv`**)하고, 원래 파일을 Git에서 삭제(**`git rm`**)하며, 새로운 파일을 Staging Area에 추가(**`git add`**)하는 것이다. 이를 수동으로 수행하는 방법은 다음과 같다
        
        ```bash
        $ mv old_filename new_filename
        $ git rm old_filename
        $ git add new_filename
        ```
        
        이렇게 **`git mv`** 명령어를 사용하는 것은 간편하며, Git이 파일 이름 변경을 자동으로 감지하고 Staging Area에 반영해준다.
        
        `git mv` 명령은 일종의 단축 명령어이다. 이 명령으로 파일 이름을 바꿔도 되고 `mv` 명령으로 파일 이름을 직접 바꿔도 된다. 단지 `git mv` 명령은 편리하게 명령을 세 번 실행해주는 것 뿐이다. 어떤 도구로 이름을 바꿔도 상관없다. 중요한 것은 이름을 변경하고 나서 꼭 rm/add 명령을 실행해야 한다는 것 뿐이다.
        
- 2-3 커밋 히스토리 조회하기
    
    Git의 **`git log`** 명령을 사용하여 커밋 히스토리를 확인할 수 있으며, 여러 가지 옵션들을 통해 출력 형식을 조절하거나 특정 기간이나 저자에 해당하는 커밋만을 조회하는 것이 가능하다.
    
    - **기본 조회**
        
         **`git log`** 명령만으로 기본적인 히스토리를 조회할 수 있다. 이는 커밋의 SHA-1 체크섬, 저자 이름, 저자 이메일, 커밋한 날짜, 커밋 메시지를 시간 순으로 보여준다.
        
    - **diff 결과 보기**
        
         **`p`** 또는 **`-patch`** 옵션을 사용하여 각 커밋의 diff 결과를 볼 수 있다.
        
        ```bash
        $ git log -p
        ```
        
    - **최근 n개의 결과만 보기**
        
        **`n`** 옵션을 사용하여 최근 n개의 커밋만 조회할 수 있다. 예를 들어, 최근 2개의 커밋만 조회하려면 아래와 같이 실행된다.
        
        ```bash
        $ git log -2
        ```
        
    - **통계 정보 보기**
        
        **`-stat`** 옵션을 사용하여 각 커밋의 통계 정보를 볼 수 있다.
        
        ```bash
        $ git log --stat
        ```
        
    - **pretty 옵션 사용하기**
        
        **`-pretty`** 옵션으로 출력 형식을 지정할 수 있으며 **`oneline`**, **`short`**, **`full`**, **`fuller`**, **`format`** 등이 사용될 수 있다. **`format`** 옵션은 사용자 정의 형식으로 출력하고 싶을 때 사용한다.
        
        ```bash
        $ git log --pretty=oneline
        $ git log --pretty=format:"%h - %an, %ar : %s"
        ```
        
    - **시간 기준으로 조회하기**
        
        **`-since`** 또는 **`-until`** 옵션을 사용하여 특정 시간 이후 또는 이전의 커밋만 조회할 수 있다.
        
        ```bash
        $ git log --since=2.weeks
        ```
        
    - **저자로 검색하기**
        
        **`-author`** 옵션을 사용하여 특정 저자의 커밋만 조회할 수 있다.
        
    - **커밋 메시지로 검색하기**
        
         **`-grep`** 옵션으로 커밋 메시지에서 키워드를 검색할 수 있다.
        
    - **코드 변경 내용으로 검색하기**
        
        **`S`** 옵션을 사용하여 코드에서 추가되거나 제거된 내용 중에 특정 텍스트가 포함되어 있는지 검색할 수 있다.
        
    - **파일 경로로 검색하기**
        
        **`-`** 와 함께 경로 이름을 사용하여 특정 파일 또는 디렉터리와 관련된 커밋을 필터링 할 수 있다.
        
        ```bash
        $ git log -- some/directory
        $ git log -- file.txt
        ```
        
    - **브랜치 비교하기**
        
        두 브랜치 간의 차이를 비교하고 싶을 때는 다음과 같이 실행할 수있다.
        
        ```bash
        $ git log branch1..branch2
        #이 명령은 branch1에는 없고 branch2에 있는 커밋들을 보여준다
        
        ```
        
    - **그래프로 표현하기**
        
        **`--graph`** 옵션을 사용하여 브랜치와 병합의 히스토리를 ASCII 그래프로 표시할 수 있다.
        
        ```bash
        $ git log --graph
        ```
        
    - **파일 변화 내용 보기**
        
        **`-name-status`** 옵션을 사용하여 어떤 파일이 추가되었는지, 수정되었는지 또는 삭제되었는지를 표시할 수 있다.
        
        ```bash
        $ git log --name-status
        ```
        
    - **특정 파일의 변경 내역만 조회하기**
        
        **`-follow`** 옵션과 함께 파일 이름을 지정하면 해당 파일의 변경 내역만 조회할 수 있다.
        
        ```bash
        $ git log --follow filename
        ```
        
    - **특정 경로 또는 패턴에 일치하는 파일의 변경 내역 보기**
        
        **`-`** 뒤에 경로 또는 패턴을 지정하여 해당하는 파일의 변경 내역만 조회할 수 있다.
        
        ```bash
        $ git log -- '*.txt'
        ```
        
    
    이와 같이 **`git log`** 명령에는 많은 옵션이 있으며, 원하는 정보를 효율적으로 찾기 위해 다양한 방식으로 활용할 수 있다.
    
- 2-4 되돌리기
    - **커밋 수정하기**
        
        만약 마지막 커밋을 수정하고 싶다면, 수정한 파일을 먼저 Staging Area에 추가한 뒤 **`git commit --amend`** 명령어를 사용한다. 이 명령어는 마지막 커밋을 새로운 커밋으로 대체하는 것이다.
        
        ```bash
        $ git add forgotten_file
        $ git commit --amend
        ```
        
    - **Staging Area에서 파일 Unstage하기**
        
        만약 Staging Area에 실수로 파일을 추가했다면, 해당 파일을 Unstage 상태로 변경할 수 있다. 이를 위해 **`git reset HEAD <file>`** 명령어를 사용한다.
        
        ```bash
        $ git reset HEAD <file_name>
        ```
        
    - **Modified 파일 되돌리기**
        
        작업 디렉토리에서 수정한 파일을 원래 상태로 되돌리고자 한다면, **`git checkout -- <file>`** 명령어를 사용할 수 있다. 하지만 이 명령은 수정된 내용을 영구적으로 삭제하므로 주의해야 한다.
        
        ```bash
        $ git checkout -- <file_name>
        ```
        
    
    **`git checkout -- <file>`** 명령어와 **`git reset --hard`** 명령어는 사용할 때 주의가 필요하다. 이 명령어들은 변경 사항을 영구적으로 삭제하므로 되돌릴 수 없다.
    
- 2-5 리모트 저장소
    
    리모트 저장소란 Git 프로젝트를 저장하는 중앙 서버로써 인터넷이나 네트워크 어딘가에 있는 저장소를 말하며, 여러 사람들과 협업할 때 매우 유용하다. 코드를 인터넷이나 네트워크를 통해 공유하며, Push(올리기)하거나 Pull(가져오기)하는 방식으로 작업한다.
    리모트 저장소는 원격에 위치할 수도 있고, 로컬 시스템에 위치할 수도 있다. 이 경우 "remote"라는 용어는 네트워크를 통한 접근 방식을 의미한다.
    리모트 저장소와 연동하여 브랜치(branch)를 관리할 수 있으며, 리모트 저장소에 대해 Push, Pull, Fetch 등의 작업을 수행할 수 있다.
    
    - **리모트 저장소 확인**
        
        **리모트 저장소 확인**: 프로젝트에 연결된 리모트 저장소를 확인한다.
        
        ```bash
        $ git remote
        ```
        
        단축이름과 URL을 함께 보려면 **`-v`** 옵션을 사용한다.
        
        ```bash
        $ git remote -v
        ```
        
    - **리모트 저장소 추가**
        
        새로운 리모트 저장소를 추가한다. **`<단축이름>`**은 리모트 저장소를 참조하는데 사용되는 이름이고, **`<url>`**은 리모트 저장소의 주소이다.
        
        ```bash
        $ git remote add <단축이름> <url>
        ```
        
    - **리모트 저장소에서 데이터 가져오기(Fetch)**
        
        리모트 저장소에 있는 데이터를 로컬로 가져오지만, 자동으로 병합(merge)하지는 않는다.
        
        ```bash
        $ git fetch <리모트 저장소 이름>
        ```
        
    - **리모트 저장소에서 데이터 가져와서 병합하기(Pull)**
        
        리모트 저장소에 있는 데이터를 로컬로 가져와서 현재 브랜치와 자동으로 병합한다.
        
        ```bash
        $ git pull <리모트 저장소 이름> <브랜치 이름>
        ```
        
    - **리모트 저장소에 데이터 보내기(Push)**
        
        로컬의 변경사항을 리모트 저장소에 업로드한다
        
        ```bash
        $ git push <리모트 저장소 이름> <브랜치 이름>
        ```
        
    - **리모트 저장소의 상세 정보 확인**
        
        리모트 저장소의 상세 정보를 확인한다.
        
        ```bash
        $ git remote show <리모트 저장소 이름>
        ```
        
    - **리모트 저장소 이름 변경**
        
        리모트 저장소의 단축 이름을 변경한다.
        
        ```bash
        $ git remote rename <현재 이름> <새 이름>
        ```
        
    - **리모트 저장소 삭제**
        
        리모트 저장소를 삭제한다.
        
        ```bash
        $ git remote remove <리모트 저장소 이름>
        ```
        
    
    이러한 명령어들을 사용하여 리모트 저장소를 관리하고, 데이터를 주고받으며 협업하는데 필요한 작업들을 수행할 수 있다.
    
- 2-6 태그
    
    (다른 VCS처럼 Git도 태그를 지원한다. 사람들은 보통 릴리즈할 때 사용한다(v1.0, 등등). 이번에는 태그를 조회하고 생성하는 법과 태그의 종류를 설명한다.)
    
    Git에서 태그는 특정 커밋을 참조하는 이름이며, 주로 프로젝트의 버전을 명시하는데 사용된다. 태그에는 크게 두 가지 유형이 있다
    
    1. **Lightweight 태그**: 이 태그는 단순히 특정 커밋을 가리키는 참조에 불과하다. 추가적인 정보나 메타데이터를 포함하지 않는다.
    2. **Annotated 태그**: 이 태그는 추가적인 정보(태그를 생성한 사람의 이름, 이메일, 날짜, 태그 메시지)를 함께 저장한다. GPG를 사용하여 서명도 가능하다. 이 태그는 릴리즈 노트나 중요한 출시와 함께 사용될 때 유용하다.
    - **Git 태그와 관련된 기본 명령어들**
        - **태그 조회**
            
            모든 태그를 조회하는 명령어이다.
            
            ```bash
            $ git tag
            ```
            
        - **태그 생성 (Lightweight 태그)**
            
            Lightweight 태그를 생성한다.
            
            ```bash
            $ git tag <태그이름>
            ```
            
            예시:
            
            ```bash
            $ git tag v1.0-lightweight
            ```
            
        - **태그 생성 (Annotated 태그)**
            
            태그 메시지와 함께 Annotated 태그를 생성한다.
            
            ```bash
            $ git tag -a <태그이름> -m "<태그 메시지>"
            ```
            
            예시:
            
            ```bash
            $ git tag -a v1.0 -m "버전 1.0 릴리즈"
            ```
            
        - **태그 정보 확인**
            
            태그에 대한 상세 정보를 확인한다. Annotated 태그의 경우 태그 메시지와 추가 정보가 표시된다.
            
            ```bash
            $ git show <태그이름>
            ```
            
        - **태그 공유하기**
            
            생성한 태그를 원격 저장소에 업로드한다.
            
            ```bash
            $ git push origin <태그이름>
            ```
            
            예시:
            
            ```bash
            $ git push origin --tags
            ```
            
        - **과거 커밋에 태그 붙이기**
            
            과거의 특정 커밋에 태그를 생성할 수 있다. 이때 커밋 해시를 함께 지정한다.
            
            ```bash
            $ git tag -a <태그이름> <커밋해시> -m "<태그 메시지>"
            ```
            
            * 커밋해시 : Git의 커밋 해시는 각 커밋에 고유하게 부여되는 식별자이다. 이것은 각 커밋의 내용, 메타데이터(작성자 정보, 날짜 등), 그리고 부모 커밋의 해시를 바탕으로 생성되는 SHA-1 해시이다.
            
        - **태그에서 브랜치 생성**
            
            태그 상태에서 새로운 브랜치를 생성하여 작업할 수 있다.
            
            ```bash
            $ git checkout -b <새 브랜치 이름> <태그이름>
            ```
            
    
    Git의 **태그**는 특정 커밋에 대한 참조이며, Lightweight 태그는 단순 참조이고, Annotated 태그는 추가 정보를 가진다. 태그를 생성하고 공유함으로써 프로젝트의 버전 관리를 효율적으로 할 수 있다.
    
- 2-7 Git Alias
    
    Git에서 **`alias`** 기능은 자주 사용하는 명령어들을 더 짧고 간결한 버전으로 만들어 준다. 
    사용자가 명령어를 더 빠르게 입력하고, 효율적으로 작업할 수 있도록 한다. 
    
    - **기본 명령어 Alias 설정**
        
        **`git config`** 명령을 사용하여 기본 Git 명령어들에 대한 alias를 설정할 수 있다.
        
        예시: **`git checkout`**을 **`git co`**로 줄여서 사용할 수 있다.
        
        ```bash
        $ git config --global alias.co checkout
        ```
        
    - **새로운 명령어 만들기**
        
        기존 명령어들을 결합하여 새로운 alias를 만들 수도 있다.
        
        예시: **`git unstage <파일명>` → `git reset HEAD -- <파일명>` 
        (**특정 파일을 Unstaged 상태로 만들 수 있음)
        
        ```bash
        #alias설정
        $ git config --global alias.unstage 'reset HEAD --'
        #아래 두 명령은 동일함
        $ git unstage fileA
        $ git reset HEAD -- fileA
        ```
        
    - **최근 커밋 확인**
        
        **`last`**라는 alias를 사용하여 최근의 커밋을 쉽게 확인할 수 있다.
        
        ```bash
        $ git config --global alias.last 'log -1 HEAD'
        $ git last
        ```
        
        **외부 명령어 실행**: **`!`**를 alias에 추가하여 Git 이외의 외부 명령어를 실행할 수 있다.
        
        예시: **`git visual`**을 입력하면 **`gitk`**가 실행된다.
        
        ```bash
        $ git config --global alias.visual '!gitk'
        ```
        
    
    Alias 기능을 사용하면 복잡한 Git 명령어를 간단하게 줄여서 사용할 수 있으며, 자주 사용하는 작업들을 더 빠르고 효율적으로 수행할 수 있다.
    
- 2-8 요약
