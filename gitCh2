### 2. GIT의 기초

- 2-1 Git 저장소 만들기
    
    배울것들 : Git 저장소를 만들고 설정하는 방법, 파일을 추적하거나 추적을 중지하는 방법, 변경 내용을 준비하고 커밋하는 방법, 그리고 리모트 저장소와 소통하는 방법.
    
    Git 저장소를 사용하는 데는 크게 두 가지 방법이 있다
    
    - 1. 아직 버전관리를 하지 않는 로컬 디렉토리 하나를 선택해서 Git 저장소를 적용하는 방법
        
        **기존 디렉토리를 Git 저장소로 만들기**
        
        이미 작업하고 있는 프로젝트 디렉토리에 Git 저장소를 생성할 수 있다. 프로젝트 디렉토리로 이동한 후, **`git init`** 명령어를 사용하면 해당 디렉토리에 **`.git`**이라는 하위 디렉토리가 생성된다. 이 디렉토리는 Git 저장소의 뼈대 파일들을 포함하고 있다. 그 후 **`git add`** 명령어로 원하는 파일을 추가하고 **`git commit`** 명령어를 사용하여 변경 사항을 커밋합니다.
        
        ```bash
        $ cd /path/to/your/project
        $ git init
        $ git add <files_to_add>
        $ git commit -m 'Your commit message'
        ```
        
    - 2. 다른 어딘가에서 Git 저장소를 Clone 하는 방법
        
        
        **기존 Git 저장소를 Clone 하기**: 다른 사람의 Git 저장소를 복제하여 자신의 로컬에 저장소를 만들 수 있습니다. 이 때 **`git clone`** 명령어를 사용합니다. 이 명령은 원격 저장소의 모든 데이터와 히스토리를 복제합니다.
        
        예시:
        
        ```bash
        $ git clone https://github.com/example/repo.git
        ```
        
        선택적으로, 저장소를 특정 디렉토리 이름으로 클론하려면 다음과 같이 실행할 수 있습니다.
        
        ```bash
        $ git clone https://github.com/example/repo.git custom_directory_name
        ```
        
        Git의 기초를 익히는 데 이 챕터는 매우 중요하며, Git의 기본 명령어를 통해 프로젝트를 효과적으로 관리하는 방법을 배울 수 있습니다.
        
- 2-2 수정하고 저장소에 저장하기
    
    Git 저장소에서 파일을 관리하는 과정은 워킹 디렉토리에서 파일을 수정하고, 이런 변경 사항들을 저장소에 기록하는 커밋을 만드는 것으로 이루어진다. 이 과정에서 파일들은 여러 상태를 거쳐간다.
    
    1. **Tracked vs Untracked**: Git은 파일을 두 가지의 큰 카테고리로 나눈다.
        - **Tracked**: 이전에 이미 커밋된 적이 있는 파일에 Git이 변경 사항을 추적한다.
        - **Untracked**: 새로 생성된 파일. 아직 Git 저장소의 스냅샷에 포함되지 않은 파일이다. Git은 이 파일들의 변경 사항을 추적하지 않는다.
    2. **Tracked 파일의 상태**: Tracked 파일은 다시 세 가지 상태로 나눠집니다.
        - **Unmodified**: 마지막 커밋 이후로 변경되지 않은 파일입니다.
        - **Modified**: 마지막 커밋 이후로 변경된 파일이지만, 아직 커밋을 준비하는 Staged 상태는 아닙니다.
        - **Staged**: 변경 사항이 있고, 다음 커밋에 이 변경사항이 포함될 준비가 된 상태입니다.
    3. **일반적인 작업 흐름**:
        - **수정**: 워킹 디렉토리에서 파일을 수정합니다. 이 때, 수정된 파일은 Modified 상태가 됩니다.
        - **Staging**: 수정한 파일을 다음 커밋에 포함시키기 위해 Staged 상태로 만듭니다. 이를 위해 **`git add <파일명>`** 명령을 사용합니다.
        - **커밋**: Staged 상태인 파일들의 스냅샷을 저장소에 기록합니다. 이를 위해 **`git commit`** 명령을 사용합니다.
    
    이러한 과정을 반복하면서 워킹 디렉토리의 변경 사항들을 Git 저장소에 안전하게 기록하게 됩니다. 이는 코드의 이력을 관리하고, 필요할 때 이전 상태로 되돌릴 수 있는 능력을 제공하는 데 중요합니다.
    
- 2-3 커밋 히스토리 조회하기
- 2-4 되돌리기
- 2-5 리모트 저장소
- 2-6 태그
    
    (다른 VCS처럼 Git도 태그를 지원한다. 사람들은 보통 릴리즈할 때 사용한다(v1.0, 등등). 이번에는 태그를 조회하고 생성하는 법과 태그의 종류를 설명한다.)
    
    Git에서 태그는 특정 커밋을 참조하는 이름이며, 주로 프로젝트의 버전을 명시하는데 사용된다. 태그에는 크게 두 가지 유형이 있다
    
    1. **Lightweight 태그**: 이 태그는 단순히 특정 커밋을 가리키는 참조에 불과하다. 추가적인 정보나 메타데이터를 포함하지 않는다.
    2. **Annotated 태그**: 이 태그는 추가적인 정보(태그를 생성한 사람의 이름, 이메일, 날짜, 태그 메시지)를 함께 저장한다. GPG를 사용하여 서명도 가능하다. 이 태그는 릴리즈 노트나 중요한 출시와 함께 사용될 때 유용하다.
    - **Git 태그와 관련된 기본 명령어들**
        - **태그 조회**
            
            모든 태그를 조회하는 명령어이다.
            
            ```bash
            $ git tag
            ```
            
        - **태그 생성 (Lightweight 태그)**
            
            Lightweight 태그를 생성한다.
            
            ```bash
            phpCopy code
            $ git tag <태그이름>
            ```
            
            예시:
            
            ```bash
            $ git tag v1.0-lightweight
            ```
            
        - **태그 생성 (Annotated 태그)**
            
            태그 메시지와 함께 Annotated 태그를 생성한다.
            
            ```bash
            $ git tag -a <태그이름> -m "<태그 메시지>"
            ```
            
            예시:
            
            ```bash
            $ git tag -a v1.0 -m "버전 1.0 릴리즈"
            ```
            
        - **태그 정보 확인**
            
            태그에 대한 상세 정보를 확인한다. Annotated 태그의 경우 태그 메시지와 추가 정보가 표시된다.
            
            ```bash
            $ git show <태그이름>
            ```
            
        - **태그 공유하기**
            
            생성한 태그를 원격 저장소에 업로드한다.
            
            ```bash
            $ git push origin <태그이름>
            ```
            
            예시:
            
            ```bash
            $ git push origin --tags
            ```
            
        - **과거 커밋에 태그 붙이기**
            
            과거의 특정 커밋에 태그를 생성할 수 있다. 이때 커밋 해시를 함께 지정한다.
            
            ```bash
            $ git tag -a <태그이름> <커밋해시> -m "<태그 메시지>"
            ```
            
            * 커밋해시 : Git의 커밋 해시는 각 커밋에 고유하게 부여되는 식별자이다. 이것은 각 커밋의 내용, 메타데이터(작성자 정보, 날짜 등), 그리고 부모 커밋의 해시를 바탕으로 생성되는 SHA-1 해시이다.
            
        - **태그에서 브랜치 생성**
            
            태그 상태에서 새로운 브랜치를 생성하여 작업할 수 있다.
            
            ```bash
            $ git checkout -b <새 브랜치 이름> <태그이름>
            ```
            
    
    Git의 **태그**는 특정 커밋에 대한 참조이며, Lightweight 태그는 단순 참조이고, Annotated 태그는 추가 정보를 가진다. 태그를 생성하고 공유함으로써 프로젝트의 버전 관리를 효율적으로 할 수 있다.
    
- 2-7 Git Alias
    
    Git에서 **`alias`** 기능은 자주 사용하는 명령어들을 더 짧고 간결한 버전으로 만들어 준다. 
    사용자가 명령어를 더 빠르게 입력하고, 효율적으로 작업할 수 있도록 한다. 
    
    - **기본 명령어 Alias 설정**
        
        **`git config`** 명령을 사용하여 기본 Git 명령어들에 대한 alias를 설정할 수 있다.
        
        예시: **`git checkout`**을 **`git co`**로 줄여서 사용할 수 있다.
        
        ```bash
        $ git config --global alias.co checkout
        ```
        
    - **새로운 명령어 만들기**
        
        기존 명령어들을 결합하여 새로운 alias를 만들 수도 있다.
        
        예시: **`git unstage <파일명>` → `git reset HEAD -- <파일명>` 
        (**특정 파일을 Unstaged 상태로 만들 수 있음)
        
        ```bash
        #alias설정
        $ git config --global alias.unstage 'reset HEAD --'
        #아래 두 명령은 동일함
        $ git unstage fileA
        $ git reset HEAD -- fileA
        ```
        
    - **최근 커밋 확인**
        
        **`last`**라는 alias를 사용하여 최근의 커밋을 쉽게 확인할 수 있다.
        
        ```bash
        $ git config --global alias.last 'log -1 HEAD'
        $ git last
        ```
        
        **외부 명령어 실행**: **`!`**를 alias에 추가하여 Git 이외의 외부 명령어를 실행할 수 있다.
        
        예시: **`git visual`**을 입력하면 **`gitk`**가 실행된다.
        
        ```bash
        $ git config --global alias.visual '!gitk'
        ```
        
    
    Alias 기능을 사용하면 복잡한 Git 명령어를 간단하게 줄여서 사용할 수 있으며, 자주 사용하는 작업들을 더 빠르고 효율적으로 수행할 수 있다.
    
- 2-8 요약
